#!/usr/bin/env bash

# info - a CLI Bash script to show system/theme info in screenshots

# Adapted on the work from Copyright (c) 2010-2019 Brett Bohnenkamper <kittykatt@kittykatt.us>
# Copyright (c) 2020 Bob Liotta <bob@bobdot.me>

#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.


scriptVersion="3.9.1"

######################
# Settings for fetcher
######################

# This setting controls what ASCII logo is displayed.
# distro="Linux"

# This sets the information to be displayed. Available: distro, Kernel, DE, WM, Win_theme, Theme, Icons, Font, Background, ASCII.
# To get just the information, and not a text-art logo, you would take "ASCII" out of the below variable.
valid_display=(
		'distro'
		'host'
		'kernel'
		'uptime'
		'shell'
		'res'
		'de'
		'wm'
		'wmtheme'
		'gtk'
		'disk'
		'cpu'
		'gpu'
		'mem'
)
display=(
		'distro'
		'host'
		'kernel'
		'uptime'
		'shell'
		'res'
		'de'
		'wm'
		'wmtheme'
		'gtk'
		'cpu'
		'disk'
		'gpu'
		'mem'
		'node'
		'ip'
		'sa'
		'namespace'
		'pod'
)
# Display Type: ASCII or Text
display_type="ASCII"
# Plain logo
display_logo="no"


# Screenshot Settings
# This setting lets the script know if you want to take a screenshot or not. 1=Yes 0=No
screenshot=
# This setting lets the script know if you want to upload the screenshot to a filehost. 1=Yes 0=No
upload=
# This setting lets the script know where you would like to upload the file to.
# Valid hosts are: teknik, mediacrush, imgur, hmp, and a configurable local.
uploadLoc=
# You can specify a custom screenshot command here. Just uncomment and edit.
# Otherwise, we'll be using the default command: scrot -cd3.

# Verbose Setting - Set to 1 for verbose output.
verbosity=


# The below function will allow you to add custom lines of text to the info output.
# It will automatically be executed at the right moment if use_customlines is set to 1.
use_customlines=
customlines () {
	# The following line can serve as an example.
	# feel free to let the computer generate the output: e. g. using $(cat /etc/motd) or $(upower -d | grep THISORTHAT)
	# In the example custom0 line replace <YOUR LABEL> and <your text> with options specified by you.
	# Also make sure the $custom0 variable in out_array=... matches the one at the beginning of the line
	#
	custom0=$(echo -e "$labelcolor YOUR LABEL:$textcolor your text"); out_array=( "${out_array[@]}" "$custom0" ); ((display_index++));

	# Battery percentage and time to full/empty:
	# (uncomment lines below to use)
	#
	#custom1=$(echo -e "$labelcolor Battery:$textcolor $(upower -d | grep percentage | head -n1 | cut -d ' ' -f 15-)"); out_array=( "${out_array[@]}" "$custom1" ); ((display_index++));
	#if [ "$(upower -d | grep time)" ]; then
	#	battery_time="$(upower -d | grep time | head -n1 | cut -d ' ' -f 14-) $(upower -d | grep time | head -n1 | cut -d ' ' -f 6-7 | cut -d ':' -f1)"
	#else
	#	battery_time="power supply plugged in"
	#fi
	#custom2=$(echo -e "$labelcolor $(echo '  `->')$textcolor $battery_time"); out_array=( "${out_array[@]}" "$custom2" ); ((display_index++));

	# Display public IP:
	#custom3=$(echo -e "$labelcolor Public IP:$textcolor $(curl -s ipinfo.io/ip)"); out_array=( "${out_array[@]}" "$custom3" ); ((display_index++));

	###########################################
	##	MY CUSTOM LINES
	###########################################

	#custom4=...
}


#############################################
#### CODE No need to edit past here CODE ####
#############################################

# https://github.com/KittyKatt/screenFetch/issues/549
if [[ "${OSTYPE}" =~ "linux" || "${OSTYPE}" == "gnu" ]]; then
	# issue seems to affect Ubuntu; add LSB directories if it appears on other distros too
	export GIO_EXTRA_MODULES="/usr/lib/x86_64-linux-gnu/gio/modules:/usr/lib/i686-linux-gnu/gio/modules:$GIO_EXTRA_MODULES"
fi

#########################################
# Static Variables and Common Functions #
#########################################
c0=$'\033[0m' # Reset Text
bold=$'\033[1m' # Bold Text
underline=$'\033[4m' # Underline Text
display_index=0

# User options
gtk_2line="no"

# Static Color Definitions
colorize () {
	printf $'\033[0m\033[38;5;%sm' "$1"
}
getColor () {
	local tmp_color=""
	if [[ -n "$1" ]]; then
		if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
			if [[ ${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]} -gt 1 ]] || [[ ${BASH_VERSINFO[0]} -gt 4 ]]; then
				tmp_color=${1,,}
			else
				tmp_color="$(tr '[:upper:]' '[:lower:]' <<< "${1}")"
			fi
		else
			tmp_color="$(tr '[:upper:]' '[:lower:]' <<< "${1}")"
		fi
		case "${tmp_color}" in
			# Standards
			'black')					color_ret='\033[0m\033[30m';;
			'red')						color_ret='\033[0m\033[31m';;
			'green')					color_ret='\033[0m\033[32m';;
			'brown')					color_ret='\033[0m\033[33m';;
			'blue')						color_ret='\033[0m\033[34m';;
			'purple')					color_ret='\033[0m\033[35m';;
			'cyan')						color_ret='\033[0m\033[36m';;
			'yellow')					color_ret='\033[0m\033[1;33m';;
			'white')					color_ret='\033[0m\033[1;37m';;
			# Bolds
			'dark grey'|'dark gray')	color_ret='\033[0m\033[1;30m';;
			'light red')				color_ret='\033[0m\033[1;31m';;
			'light green')				color_ret='\033[0m\033[1;32m';;
			'light blue')				color_ret='\033[0m\033[1;34m';;
			'light purple')				color_ret='\033[0m\033[1;35m';;
			'light cyan')				color_ret='\033[0m\033[1;36m';;
			'light grey'|'light gray')	color_ret='\033[0m\033[37m';;
			# Some 256 colors
			'orange')					color_ret="$(colorize '202')";; #DarkOrange
			'light orange') 			color_ret="$(colorize '214')";; #Orange1
			# HaikuOS
			'black_haiku') 				color_ret="$(colorize '7')";;
			#ROSA color
			'rosa_blue') 				color_ret='\033[01;38;05;25m';;
			# ArcoLinux
			'arco_blue') color_ret='\033[1;38;05;111m';;
		esac
		[[ -n "${color_ret}" ]] && echo "${color_ret}"
	fi
}

verboseOut () {
	if [[ "$verbosity" -eq "1" ]]; then
		printf '\033[1;31m:: \033[0m%s\n' "$1"
	fi
}

errorOut () {
	printf '\033[1;37m[[ \033[1;31m! \033[1;37m]] \033[0m%s\n' "$1"
}
stderrOut () {
	while IFS='' read -r line; do
		printf '\033[1;37m[[ \033[1;31m! \033[1;37m]] \033[0m%s\n' "$line"
	done
}


####################
#  Color Defines
####################

colorNumberToCode () {
	local number="$1"
	if [[ "${number}" == "na" ]]; then
		unset code
	elif [[ $(tput colors) -eq "256" ]]; then
		code=$(colorize "${number}")
	else
		case "$number" in
			0|00) code=$(getColor 'black');;
			1|01) code=$(getColor 'red');;
			2|02) code=$(getColor 'green');;
			3|03) code=$(getColor 'brown');;
			4|04) code=$(getColor 'blue');;
			5|05) code=$(getColor 'purple');;
			6|06) code=$(getColor 'cyan');;
			7|07) code=$(getColor 'light grey');;
			8|08) code=$(getColor 'dark grey');;
			9|09) code=$(getColor 'light red');;
			  10) code=$(getColor 'light green');;
			  11) code=$(getColor 'yellow');;
			  12) code=$(getColor 'light blue');;
			  13) code=$(getColor 'light purple');;
			  14) code=$(getColor 'light cyan');;
			  15) code=$(getColor 'white');;
			*) unset code;;
		esac
	fi
	echo -n "${code}"
}


detectColors () {
	my_colors=$(sed 's/^,/na,/;s/,$/,na/;s/,/ /' <<< "${OPTARG}")
	my_lcolor=$(awk -F' ' '{print $1}' <<< "${my_colors}")
	my_lcolor=$(colorNumberToCode "${my_lcolor}")
	my_hcolor=$(awk -F' ' '{print $2}' <<< "${my_colors}")
	my_hcolor=$(colorNumberToCode "${my_hcolor}")
}

supported_distros="BOB" 

supported_other=""

supported_dms=""

supported_wms=""

displayHelp () {
	echo "${underline}Usage${c0}:"
	echo "  ${0} [OPTIONAL FLAGS]"
	echo
	echo "screenFetch - a CLI Bash script to show system/theme info in screenshots."
	echo
	echo "${underline}Supported GNU/Linux Distributions${c0}:"
	echo "${supported_distros}" | fold -s | sed 's/^/\t/g'
	echo
	echo "${underline}Other Supported Systems${c0}:"
	echo "${supported_other}" | fold -s | sed 's/^/\t/g'
	echo
	echo "${underline}Supported Desktop Managers${c0}:"
	echo "${supported_dms}" | fold -s | sed 's/^/\t/g'
	echo
	echo "${underline}Supported Window Managers${c0}:"
	echo "${supported_wms}" | fold -s | sed 's/^/\t/g'
	echo
	echo "${underline}Supported Information Displays${c0}:"
	echo "${valid_display[@]}" | fold -s | sed 's/^/\t/g'
	echo
	echo "${underline}Options${c0}:"
	echo "   ${bold}-v${c0}                 Verbose output."
	echo "   ${bold}-o 'OPTIONS'${c0}       Allows for setting script variables on the"
	echo "                      command line. Must be in the following format..."
	echo "                      'OPTION1=\"OPTIONARG1\";OPTION2=\"OPTIONARG2\"'"
	echo "   ${bold}-d '+var;-var;var'${c0} Allows for setting what information is displayed"
	echo "                      on the command line. You can add displays with +var,var. You"
	echo "                      can delete displays with -var,var. Setting without + or - will"
	echo "                      set display to that explicit combination. Add and delete statements"
	echo "                      may be used in conjunction by placing a ; between them as so:"
	echo "                      +var,var,var;-var,var. See above to find supported display names."
	echo "   ${bold}-n${c0}                 Do not display ASCII distribution logo."
	echo "   ${bold}-L${c0}                 Display ASCII distribution logo only."
	echo "   ${bold}-N${c0}                 Strip all color from output."
	echo "   ${bold}-w${c0}                 Wrap long lines."
	echo "   ${bold}-t${c0}                 Truncate output based on terminal width (Experimental!)."
	echo "   ${bold}-p${c0}                 Portrait output."
	echo "   ${bold}-s [-u IMGHOST]${c0}    Using this flag tells the script that you want it"
	echo "                      to take a screenshot. Use the -u flag if you would like"
	echo "                      to upload the screenshots to one of the pre-configured"
	echo "                      locations. These include: teknik, imgur, mediacrush and hmp."
	echo "   ${bold}-c string${c0}          You may change the outputted colors with -c. The format is"
	echo "                      as follows: [0-9][0-9],[0-9][0-9]. The first argument controls the"
	echo "                      ASCII logo colors and the label colors. The second argument"
	echo "                      controls the colors of the information found. One argument may be"
	echo "                      used without the other. For terminals supporting 256 colors argument"
	echo "                      may also contain other terminal control codes for bold, underline etc."
	echo "                      separated by semicolon. For example -c \"4;1,1;2\" will produce bold"
	echo "                      blue and dim red."
	echo "   ${bold}-a 'PATH'${c0}          You can specify a custom ASCII art by passing the path"
	echo "                      to a Bash script, defining \`startline\` and \`fulloutput\`"
	echo "                      variables, and optionally \`labelcolor\` and \`textcolor\`."
	echo "                      See the \`asciiText\` function in the source code for more"
	echo "                      information on the variables format."
	echo "   ${bold}-S 'COMMAND'${c0}       Here you can specify a custom screenshot command for"
	echo "                      the script to execute. Surrounding quotes are required."
	echo "   ${bold}-D 'DISTRO'${c0}        Here you can specify your distribution for the script"
	echo "                      to use. Surrounding quotes are required."
	echo "   ${bold}-A 'DISTRO'${c0}        Here you can specify the distribution art that you want"
	echo "                      displayed. This is for when you want your distro"
	echo "                      detected but want to display a different logo."
	echo "   ${bold}-E${c0}                 Suppress output of errors."
	echo "   ${bold}-V, --version${c0}      Display current script version."
	echo "   ${bold}-h, --help${c0}         Display this help."
}


displayVersion () {
	echo "${underline}screenFetch${c0} - Version ${scriptVersion}"
	echo "Created by and licensed to Brett Bohnenkamper <kittykatt@kittykatt.us>"
	echo "OS X porting done almost solely by shrx (https://github.com/shrx) and John D. Duncan, III (https://github.com/JohnDDuncanIII)."
	echo
	echo "This is free software; see the source for copying conditions.  There is NO warranty; not even MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
}


#####################
# Begin Flags Phase
#####################

case $1 in
	--help) displayHelp; exit 0;;
	--version) displayVersion; exit 0;;
esac


while getopts ":hsu:evVEnLNtlS:A:D:o:c:d:pa:w" flags; do
	case $flags in
		h) displayHelp; exit 0 ;;
		s) screenshot='1' ;;
		S) screenCommand="${OPTARG}" ;;
		u) upload='1'; uploadLoc="${OPTARG}" ;;
		v) verbosity=1 ;;
		V) displayVersion; exit 0 ;;
		E) errorSuppress='1' ;;
		D) distro="${OPTARG}" ;;
		A) asc_distro="${OPTARG}" ;;
		t) truncateSet='Yes' ;;
		n) display_type='Text' ;;
		L) display_type='ASCII'; display_logo='Yes' ;;
		o) overrideOpts="${OPTARG}" ;;
		c) detectColors "${OPTARGS}" ;;
		d) overrideDisplay="${OPTARG}" ;;
		N) no_color='1' ;;
		p) portraitSet='Yes' ;;
		a) art="${OPTARG}" ;;
		w) lineWrap='Yes' ;;
		:) errorOut "Error: You're missing an argument somewhere. Exiting."; exit 1 ;;
		?) errorOut "Error: Invalid flag somewhere. Exiting."; exit 1 ;;
		*) errorOut "Error"; exit 1 ;;
	esac
done

###################
# End Flags Phase
###################


############################
# Override Options/Display
############################

if [[ "$overrideOpts" ]]; then
	verboseOut "Found 'o' flag in syntax. Overriding some script variables..."
	eval "${overrideOpts}"
fi


#########################
# Begin Detection Phase
#########################

# Distro Detection - Begin
detectdistro () {

  distro="BOB"

}
# Distro Detection - End

# Host and User detection - Begin
detecthost () {
	myUser=${USER}
	myHost=${HOSTNAME}
	if [[ -z "$USER" ]]; then
		myUser=$(whoami)
	fi
	if [[ "${distro}" == "Mac OS X" ]]; then
		myHost=${myHost/.local}
	fi
	verboseOut "Finding hostname and user...found as '${myUser}@${myHost}'"
}

# Find Number of Running Processes
# processnum="$(( $( ps aux | wc -l ) - 1 ))"

# Kernel Version Detection - Begin
detectkernel () {
	if [[ "$distro" == "OpenBSD" ]]; then
		kernel=$(uname -a | cut -f 3- -d ' ')
	else
		# compatibility for older versions of OS X:
		kernel=$(uname -m && uname -sr)
		kernel=${kernel//$'\n'/ }
		#kernel=( $(uname -srm) )
		#kernel="${kernel[${#kernel[@]}-1]} ${kernel[@]:0:${#kernel[@]}-1}"
		verboseOut "Finding kernel version...found as '${kernel}'"
	fi
}
# Kernel Version Detection - End


# Uptime Detection - Begin
detectuptime () {
	unset uptime
	if [[ -f /proc/uptime ]]; then
		uptime=$(</proc/uptime)
		uptime=${uptime//.*}
	fi

	verboseOut "Finding current uptime...found as '${uptime}'"
}
# Uptime Detection - End



# CPU Detection - Begin
detectcpu () {
	local REGEXP="-r"
	if [ "$distro" == "Mac OS X" ]; then
		cpu=$(machine)
		if [[ $cpu == "ppc750" ]]; then
			cpu="IBM PowerPC G3"
		elif [[ $cpu == "ppc7400" || $cpu == "ppc7450" ]]; then
			cpu="IBM PowerPC G4"
		elif [[ $cpu == "ppc970" ]]; then
			cpu="IBM PowerPC G5"
		else
			cpu=$(sysctl -n machdep.cpu.brand_string)
		fi
		REGEXP="-E"
	elif [ "$OSTYPE" == "gnu" ]; then
		# no /proc/cpuinfo on GNU/Hurd
		if uname -m | grep -q 'i.86'; then
			cpu="Unknown x86"
		else
			cpu="Unknown"
		fi
	elif [ "$distro" == "FreeBSD" ]; then
		cpu=$(dmesg | awk -F': ' '/^CPU/ {gsub(/ +/," "); gsub(/\([^\(\)]*\)|CPU /,"", $2); print $2; exit}')
	elif [ "$distro" == "DragonFlyBSD" ]; then
		cpu=$(sysctl -n hw.model)
	elif [ "$distro" == "OpenBSD" ]; then
		cpu=$(sysctl -n hw.model | sed 's/@.*//')
	elif [ "$distro" == "Haiku" ]; then
		cpu=$(sysinfo -cpu | awk -F': ' '/^CPU #0/ {gsub(/ +/," "); gsub(/\([^\(\)]*\)|CPU /,"", $2); print $2; exit}')
	else
		cpu=$(awk -F':' '/^model name/ {split($2, A, " @"); print A[1]; exit}' /proc/cpuinfo)
		cpun=$(grep -c '^processor' /proc/cpuinfo)
		if [ -z "$cpu" ]; then
			cpu=$(awk 'BEGIN{FS=":"} /Hardware/ { print $2; exit }' /proc/cpuinfo)
		fi
		if [ -z "$cpu" ]; then
			cpu=$(awk 'BEGIN{FS=":"} /^cpu/ { gsub(/  +/," ",$2); print $2; exit}' /proc/cpuinfo | sed 's/, altivec supported//;s/^ //')
			if [[ $cpu =~ ^(PPC)*9.+ ]]; then
				model="IBM PowerPC G5 "
			elif [[ $cpu =~ 740/750 ]]; then
				model="IBM PowerPC G3 "
			elif [[ $cpu =~ ^74.+ ]]; then
				model="Motorola PowerPC G4 "
			elif [[ $cpu =~ ^POWER.* ]]; then
				model="IBM POWER "
			elif grep -q -i 'BCM2708' /proc/cpuinfo ; then
				model="Broadcom BCM2835 ARM1176JZF-S"
			else
				arch=$(uname -m)
				if [[ "$arch" == "s390x" || "$arch" == "s390" ]]; then
					cpu=""
					args=$(grep 'machine' /proc/cpuinfo | sed 's/^.*://g; s/ //g; s/,/\n/g' | grep '^machine=.*')
					eval "$args"
					case "$machine" in
						# information taken from https://github.com/SUSE/s390-tools/blob/master/cputype
						2064) model="IBM eServer zSeries 900" ;;
						2066) model="IBM eServer zSeries 800" ;;
						2084) model="IBM eServer zSeries 990" ;;
						2086) model="IBM eServer zSeries 890" ;;
						2094) model="IBM System z9 Enterprise Class" ;;
						2096) model="IBM System z9 Business Class" ;;
						2097) model="IBM System z10 Enterprise Class" ;;
						2098) model="IBM System z10 Business Class" ;;
						2817) model="IBM zEnterprise 196" ;;
						2818) model="IBM zEnterprise 114" ;;
						2827) model="IBM zEnterprise EC12" ;;
						2828) model="IBM zEnterprise BC12" ;;
						2964) model="IBM z13" ;;
						   *) model="IBM S/390 machine type $machine" ;;
					esac
				else
					model="Unknown"
				fi
			fi
			cpu="${model}${cpu}"
		fi
		loc="/sys/devices/system/cpu/cpu0/cpufreq"
		bl="${loc}/bios_limit"
		smf="${loc}/scaling_max_freq"
		if [ -f "$bl" ] && [ -r "$bl" ]; then
			cpu_mhz=$(awk '{print $1/1000}' "$bl")
		elif [ -f "$smf" ] && [ -r "$smf" ]; then
			cpu_mhz=$(awk '{print $1/1000}' "$smf")
		else
			cpu_mhz=$(awk -F':' '/cpu MHz/{ print int($2+.5) }' /proc/cpuinfo | head -n 1)
		fi
		if [ -n "$cpu_mhz" ]; then
			if [ "${cpu_mhz%.*}" -ge 1000 ]; then
				cpu_ghz=$(awk '{print $1/1000}' <<< "${cpu_mhz}")
				cpufreq="${cpu_ghz}GHz"
			else
				cpufreq="${cpu_mhz}MHz"
			fi
		fi
	fi
	if [[ "${cpun}" -gt "1" ]]; then
		cpun="${cpun}x "
	else
		cpun=""
	fi
	if [ -z "$cpufreq" ]; then
		cpu="${cpun}${cpu}"
	else
		cpu="$cpu @ ${cpun}${cpufreq}"
	fi
	if [ -d '/sys/class/hwmon/' ]; then
		for dir in /sys/class/hwmon/* ; do
			hwmonfile=""
			[ -e "$dir/name" ] && hwmonfile=$dir/name
			[ -e "$dir/device/name" ] && hwmonfile=$dir/device/name
			[ -n "$hwmonfile" ] && if grep -q 'coretemp' "$hwmonfile"; then
				thermal="$dir/temp1_input"
				break
			fi
		done
		if [ -e "$thermal" ] && [ "${thermal:+isSetToNonNull}" = 'isSetToNonNull' ]; then
			temperature=$(bc <<< "scale=1; $(cat "$thermal")/1000")
		fi
	fi
	if [ -n "$temperature" ]; then
		cpu="$cpu [${temperature}°C]"
	fi
	cpu=$(sed $REGEXP 's/\([tT][mM]\)|\([Rr]\)|[pP]rocessor|CPU//g' <<< "${cpu}" | xargs)
	verboseOut "Finding current CPU...found as '$cpu'"
}
# CPU Detection - End


# GPU Detection - Begin (EXPERIMENTAL!)
detectgpu () {
	if [[ "${distro}" == "FreeBSD" || "${distro}" == "DragonFlyBSD" ]]; then
		nvisettexist=$(which nvidia-settings)
		if [ -x "$nvisettexist" ]; then
			gpu="$(nvidia-settings -t -q gpus | grep \( | sed 's/.*(\(.*\))/\1/')"
		else
			gpu_info=$(pciconf -lv 2> /dev/null | grep -B 4 VGA)
			gpu_info=$(grep -E 'device.*=.*' <<< "${gpu_info}")
			gpu="${gpu_info##*device*= }"
			gpu="${gpu//\'}"
			# gpu=$(sed 's/.*device.*= //' <<< "${gpu_info}" | sed "s/'//g")
		fi
	elif [[ "${distro}" == "OpenBSD" ]]; then
		gpu=$(glxinfo 2> /dev/null | awk '/OpenGL renderer string/ { sub(/OpenGL renderer string: /,""); print }')
	elif [[ "${distro}" == "Mac OS X" ]]; then
		gpu=$(system_profiler SPDisplaysDataType | awk -F': ' '/^ *Chipset Model:/ {print $2}' | awk '{ printf "%s / ", $0 }' | sed -e 's/\/ $//g')
	elif [[ "${distro}" == "Cygwin" || "${distro}" == "Msys" ]]; then
		gpu=$(wmic path Win32_VideoController get caption | sed -n '2p')
	elif [[ "${distro}" == "Haiku" ]]; then
		gpu="$(listdev | grep -A2 -e 'device Display controller' | awk -F': ' '/^ +device/ {print $2}')"
	else
		if [[ -n "$(PATH="/opt/bin:$PATH" type -p nvidia-smi)" ]]; then
			gpu=$($(PATH="/opt/bin:$PATH" type -p nvidia-smi | cut -f1) -q | awk -F':' '/Product Name/ {gsub(/: /,":"); print $2}' | sed ':a;N;$!ba;s/\n/, /g')
		elif [[ -n "$(PATH="/usr/sbin:$PATH" type -p glxinfo)" && -z "${gpu}" ]]; then
			gpu_info=$($(PATH="/usr/sbin:$PATH" type -p glxinfo | cut -f1) 2>/dev/null)
			gpu=$(grep "OpenGL renderer string" <<< "${gpu_info}" | cut -d ':' -f2 | sed -n -e '1h;2,$H;${g;s/\n/, /g' -e 'p' -e '}')
			gpu="${gpu:1}"
			gpu_info=$(grep "OpenGL vendor string" <<< "${gpu_info}")
		elif [[ -n "$(PATH="/usr/sbin:$PATH" type -p lspci)" && -z "$gpu" ]]; then
			gpu_info=$($(PATH="/usr/bin:$PATH" type -p lspci | cut -f1) 2> /dev/null | grep VGA)
			gpu=$(grep -oE '\[.*\]' <<< "${gpu_info}" | sed 's/\[//;s/\]//' | sed -n -e '1h;2,$H;${g;s/\n/, /g' -e 'p' -e '}')
		fi
	fi

	if [ -n "$gpu" ];then
		if grep -q -i 'nvidia' <<< "${gpu_info}"; then
			gpu_info="NVidia "
		elif grep -q -i 'intel' <<< "${gpu_info}"; then
			gpu_info="Intel "
		elif grep -q -i 'amd' <<< "${gpu_info}"; then
			gpu_info="AMD "
		elif grep -q -i 'ati' <<< "${gpu_info}" || grep -q -i 'radeon' <<< "${gpu_info}"; then
			gpu_info="ATI "
		else
			gpu_info=$(cut -d ':' -f2 <<< "${gpu_info}")
			gpu_info="${gpu_info:1} "
		fi
		gpu="${gpu}"
	else
		gpu="Not Found"
	fi

	verboseOut "Finding current GPU...found as '$gpu'"
}
# GPU Detection - End

# Detect Intel GPU  #works in dash
# Run it only on Intel Processors if GPU is unknown
DetectIntelGPU() {
	if [ -r /proc/fb ]; then
		gpu=$(awk 'BEGIN {ORS = " &"} {$1="";print}' /proc/fb | sed  -r s/'^\s+|\s*&$'//g)
	fi

	case $gpu in
		*mfb)
			gpu=$(lspci | grep -i vga | awk -F ": " '{print $2}') 
			;;
		*intel*)
			gpu="intel"
			;;
		*)
			gpu="Not Found"
			;;
	esac

	if [[ "$gpu" = "intel" ]]; then
		#Detect CPU
		local CPU=$(uname -p | awk '{print $3}')
		CPU=${CPU#*'-'}; #Detect CPU number

		#Detect Intel GPU
		case $CPU in
			[3-6][3-9][0-5]|[3-6][3-9][0-5][K-Y])
				gpu='Intel HD Graphics'
				;; #1st
			2[1-5][0-3][0-2]*|2390T|2600S)
				gpu='Intel HD Graphics 2000'
				;; #2nd
			2[1-5][1-7][0-8]*|2105|2500K)
				gpu='Intel HD Graphics 3000'
				;; #2nd
			32[1-5]0*|3[4-5][5-7]0*|33[3-4]0*)
				gpu='Intel HD Graphics 2500'
				;; #3rd
			3570K|3427U)
				gpu='Intel HD Graphics 4000'
				;; #3rd
			4[3-7][0-9][0-5]*)
				gpu='Intel HD Graphics 4600'
				;; #4th Haswell
			5[5-6]75[C-R]|5350H)
				gpu='Intel Iris Pro Graphics 6200'
				;; #5th Broadwell
				#6th Skylake
				#7th Kabylake
				#8th Cannonlake
			*)
				gpu='Unknown'
				;; #Unknown GPU model
		esac
	fi
}

# Disk Usage Detection - Begin
detectdisk () {
	diskusage="Unknown"
	if type -p df >/dev/null 2>&1; then
		if [[ "${distro}" =~ (Free|Net|DragonFly)BSD ]]; then
			totaldisk=$(df -h -c 2>/dev/null | tail -1)
		elif [[ "${distro}" == "OpenBSD" ]]; then
			totaldisk=$(df -Pk 2> /dev/null | awk '
				/^\// {total+=$2; used+=$3; avail+=$4}
				END{printf("total %.1fG %.1fG %.1fG %d%%\n", total/1048576, used/1048576, avail/1048576, used*100/total)}')
		elif [[ "${distro}" == "Mac OS X" ]]; then
			totaldisk=$(df -H / 2>/dev/null | tail -1)
		else
			totaldisk=$(df -h -x aufs -x tmpfs -x overlay --total 2>/dev/null | tail -1)
		fi
		disktotal=$(awk '{print $2}' <<< "${totaldisk}")
		diskused=$(awk '{print $3}' <<< "${totaldisk}")
		diskusedper=$(awk '{print $5}' <<< "${totaldisk}")
		diskusage="${diskused} / ${disktotal} (${diskusedper})"
		diskusage_verbose=$(sed 's/%/%%/' <<< "$diskusage")
	fi
	verboseOut "Finding current disk usage...found as '$diskusage_verbose'"
}
# Disk Usage Detection - End


# Memory Detection - Begin
detectmem () {
	mem=$(free -b | awk 'NR==2{print $2"-"$7}')
	usedmem=$((mem / 1024 / 1024))
	totalmem=$((${mem//-*} / 1024 / 1024))
	mem="${usedmem}MiB / ${totalmem}MiB"
	verboseOut "Finding current RAM usage...found as '$mem'"
}
# Memory Detection - End

# POD Detection
detectpod () {
        pod=${MY_POD_NAME}
}
# POD Detection - End

# ServiceAccount Detection
detectsa () {
        sa=${MY_POD_SERVICE_ACCOUNT}
}
# ServiceAccount Detection - End

# Namespace Detection
detectnamespace () {
        namespace=${MY_POD_NAMESPACE}
}
# Namespace Detection - End

# Node Detection
detectnode () {
        node=${MY_NODE_NAME}
}

# IP Detection
detectip () {
        ip=${MY_POD_IP}
}
# IP Detection - End

# Shell Detection - Begin
detectshell_ver () {
	local version_data='' version='' get_version='--version'

	case $1 in
		# ksh sends version to stderr. Weeeeeeird.
		ksh)
			version_data="$( $1 $get_version 2>&1 )"
			;;
		*)
			version_data="$( $1 $get_version 2>/dev/null )"
			;;
	esac

	if [[ -n $version_data ]];then
		version=$(awk '
		BEGIN {
			IGNORECASE=1
		}
		/'$2'/ {
			gsub(/(,|v|V)/, "",$'$3')
			if ($2 ~ /[Bb][Aa][Ss][Hh]/) {
				gsub(/\(.*|-release|-version\)/,"",$4)
			}
			print $'$3'
			exit # quit after first match prints
		}' <<< "$version_data")
	fi
	echo "$version"
}
detectshell () {
	if [[ ! "${shell_type}" ]]; then
		if [[ "${distro}" == "Cygwin" || "${distro}" == "Msys" || "${distro}" == "Haiku" || "${distro}" == "Alpine Linux" ||
			"${distro}" == "Mac OS X" || "${distro}" == "TinyCore" || "${distro}" == "Raspbian" || "${OSTYPE}" == "gnu" ]]; then
			shell_type=$(echo "$SHELL" | awk -F'/' '{print $NF}')
		elif readlink -f "$SHELL" 2>&1 | grep -q -i 'busybox'; then
			shell_type="BusyBox"
		else
			if [[ "${OSTYPE}" =~ "linux" ]]; then
				shell_type=$(tr '\0' '\n' </proc/$PPID/cmdline | head -1)
			elif [[ "${distro}" =~ "BSD" ]]; then
				shell_type=$(ps -p $PPID -o command | tail -1)
			else
				shell_type=$(ps -p "$(ps -p $PPID | awk '$1 !~ /PID/ {print $1}')" | awk 'FNR>1 {print $1}')
			fi
			shell_type=${shell_type/-}
			shell_type=${shell_type//*\/}
		fi
	fi

	case $shell_type in
		bash)
			shell_version_data=$( detectshell_ver "$shell_type" "^GNU.bash,.version" "4" )
			;;
		BusyBox)
			shell_version_data=$( busybox | head -n1 | cut -d ' ' -f2 )
			;;
		csh)
			shell_version_data=$( detectshell_ver "$shell_type" "$shell_type" "3" )
			;;
		dash)
			shell_version_data=$( detectshell_ver "$shell_type" "$shell_type" "3" )
			;;
		ksh)
			shell_version_data=$( detectshell_ver "$shell_type" "version" "5" )
			;;
		tcsh)
			shell_version_data=$( detectshell_ver "$shell_type" "^tcsh" "2" )
			;;
		zsh)
			shell_version_data=$( detectshell_ver "$shell_type" "^zsh" "2" )
			;;
		fish)
			shell_version_data=$( fish --version | awk '{print $3}' )
			;;
	esac

	if [[ -n $shell_version_data ]];then
		shell_type="$shell_type $shell_version_data"
	fi

	myShell=${shell_type}
	verboseOut "Finding current shell...found as '$myShell'"
}
# Shell Detection - End


# Resolution Detection - Begin
detectres () {
	xResolution="No X Server"
	verboseOut "Finding current resolution(s)...found as '$xResolution'"
}
# Resolution Detection - End


# DE Detection - Begin
detectde () {
	DE="Not Present"
	verboseOut "Finding desktop environment...found as '$DE'"
}
### DE Detection - End


# WM Detection - Begin
detectwm () {
	WM="Not Found"
	verboseOut "Finding window manager...found as '$WM'"
}
# WM Detection - End


# WM Theme Detection - BEGIN
detectwmtheme () {
	Win_theme="Not Found"
	verboseOut "Finding window manager theme...found as '$Win_theme'"
}
# WM Theme Detection - END

# GTK Theme\Icon\Font Detection - BEGIN
detectgtk () {
	gtk2Theme="Not Found"
	gtk3Theme="Not Found"
	gtkIcons="Not Found"
	gtkFont="Not Found"
	verboseOut "Finding GTK2 theme...found as '$gtk2Theme'"
	verboseOut "Finding GTK3 theme...found as '$gtk3Theme'"
	verboseOut "Finding icon theme...found as '$gtkIcons'"
	verboseOut "Finding user font...found as '$gtkFont'"
	#if [[ -n "$gtkBackground" ]]; then
	#	verboseOut "Finding background...found as '$gtkBackground'"
	#fi
}
# GTK Theme\Icon\Font Detection - END

# Android-specific detections
detectdroid () {
	distro_ver=$(getprop ro.build.version.release)
	hostname=$(getprop net.hostname)
	device="$(getprop ro.product.model) ($(getprop ro.product.device))"
	if [[ $(getprop ro.build.host) == "cyanogenmod" ]]; then
		rom=$(getprop ro.cm.version)
	else
		rom=$(getprop ro.build.display.id)
	fi
	baseband=$(getprop ro.baseband)
	cpu=$(awk -F': ' '/^Processor/ {P=$2} /^Hardware/ {H=$2} END {print H != "" ? H : P}' /proc/cpuinfo)
}


#######################
# End Detection Phase
#######################


asciiText () {
# Distro logos and ASCII outputs
	if [[ "$asc_distro" ]]; then
		myascii="${asc_distro}"
	elif [[ "$art" ]]; then
		myascii="custom"
	#elif [[ "$fake_distro" ]]; then
	#	myascii="${fake_distro}"
	else
		myascii="${distro}"
	fi
	case ${myascii} in
		"custom")
			source "$art"
		;;
		"BOB")
			if [[ "$no_color" != "1" ]]; then
				c1=$(getColor 'white') # White
				c2=$(getColor 'cyan') # Cyan
				c3=$(getColor 'black') # Black
				c4=$(getColor 'blue') # Blue
				c5=$(getColor 'red') # Red
                                b="█" # A Block Character
			fi
			if [ -n "${my_lcolor}" ]; then c1="${my_lcolor}"; c2="${my_lcolor}"; fi
			startline="0"
			logowidth="36"
			fulloutput=(

"                                        %s"
"${c2}   ${b}${b}${b}${b}${b}${b}${b}${b}        ${c5}/${b}${c2}       ${b}${b}${b}${b}${b}${b}${b}${b}    %s"
"${c2}   ${b}${b}${b}${b}${b}${b}${b}${b}${b}       ${c5}${b}${b}${c2}       ${b}${b}${b}${b}${b}${b}${b}${b}${b}   %s"
"${c2}   ${b}${b}      ${b}${b}       ${c5}${b}${c2}       ${b}${b}      ${b}${b}  %s"
"${c2}   ${b}${b}      ${b}${b}      ${c4}${b}${b}${b}      ${c2}${b}${b}      ${b}${b}  %s"
"${c2}   ${b}${b}${b}${b}${b}${b}${b}${b}${b}     ${c1}${b}${b}${b}${b}${b}${b}${b}${c2}    ${b}${b}${b}${b}${b}${b}${b}${b}${b}   %s"
"${c2}   ${b}${b}${b}${b}${b}${b}${b}${b}${b}    ${c1}${b}${b}${b}${b}${b}${b}${b}${b}${b}${c2}   ${b}${b}${b}${b}${b}${b}${b}${b}${b}   %s"
"${c2}   ${b}${b}      ${b}${b}  ${c1}${b}${b}  o  o ${b}${b}${c2}  ${b}${b}      ${b}${b}  %s"
"${c2}   ${b}${b}      ${b}${b}  ${c1}${b}${b}       ${b}${b}${c2}  ${b}${b}      ${b}${b}  %s"
"${c2}   ${b}${b}${b}${b}${b}${b}${b}${b}${b}    ${c1}${b}${b}${b}${b}${b}${b}${b}${b}${b}${c2}   ${b}${b}${b}${b}${b}${b}${b}${b}${b}   %s"
"${c2}   ${b}${b}${b}${b}${b}${b}${b}${b}      ${c1}${b}${b}${b}${b}${b}${b}${b}${c2}    ${b}${b}${b}${b}${b}${b}${b}${b}    %s"
"${c2}                                        %s"
"${c1}   B A S H   o n   B o a r d !          %s"
"${c2}                                        %s"
"${c4}  ${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}${b}  %s")
		;;
	esac


	# Truncate lines based on terminal width.
	if [ "$truncateSet" == "Yes" ]; then
		missinglines=$((${#out_array[*]} + startline - ${#fulloutput[*]}))
		for ((i=0; i<missinglines; i++)); do
			fulloutput+=("${c1}$(printf '%s' "$logowidth")")
		done
		for ((i=0; i<${#fulloutput[@]}; i++)); do
			my_out=$(printf "${fulloutput[i]}$c0\n" "${out_array}")
			my_out_full=$(echo "$my_out" | cat -v)
			termWidth=$(tput cols)
			#SHOPT_EXTGLOB_STATE=$(shopt -p extglob)
			#read SHOPT_CMD SHOPT_STATE SHOPT_OPT <<< "${SHOPT_EXTGLOB_STATE}"
			#if [[ ${SHOPT_STATE} == "-u" ]]; then
			#	shopt -s extglob
			#fi

			stringReal="${my_out_full//\^\[\[@([0-9]|[0-9];[0-9][0-9])m}"

			if [[ ${SHOPT_STATE} == "-u" ]]; then
				shopt -u extglob
			fi

			if [[ "${#stringReal}" -le "${termWidth}" ]]; then
				echo -e "${my_out}"$c0
			elif [[ "${#stringReal}" -gt "${termWidth}" ]]; then
				((NORMAL_CHAR_COUNT=0))
				for ((j=0; j<=${#my_out_full}; j++)); do
					if [[ "${my_out_full:${j}:3}" == '^[[' ]]; then
						if [[ "${my_out_full:${j}:5}" =~ ^\^\[\[[[:digit:]]m$ ]]; then
							if [[ ${j} -eq 0 ]]; then
								j=$((j + 5))
							else
								j=$((j + 4))
							fi
						elif [[ "${my_out_full:${j}:8}" =~ ^\^\[\[[[:digit:]]\;[[:digit:]][[:digit:]]m ]]; then
							if [[ ${j} -eq 0 ]]; then
								j=$((j + 8))
							else
								j=$((j + 7))
							fi
						fi
					else
						((NORMAL_CHAR_COUNT++))
						if [[ ${NORMAL_CHAR_COUNT} -ge ${termWidth} ]]; then
							echo -e "${my_out:0:$((j - 5))}"$c0
							break 1
						fi
					fi
				done
			fi

			if [[ "$i" -ge "$startline" ]]; then
				unset 'out_array[0]'
				out_array=( "${out_array[@]}" )
			fi
		done
	elif [[ "$portraitSet" = "Yes" ]]; then
		for i in "${!fulloutput[@]}"; do
			printf "${fulloutput[$i]}$c0\n"
		done

		printf "\n"

		for ((i=0; i<${#fulloutput[*]}; i++)); do
			[[ -z "${out_array[0]}" ]] && continue
			printf "%s\n" "${out_array[0]}"
			unset 'out_array[0]'
			out_array=( "${out_array[@]}" )
		done

	elif [[ "$display_logo" == "Yes" ]]; then
		for i in "${!fulloutput[@]}"; do
			printf "${fulloutput[i]}$c0\n"
		done
	else
		if [[ "$lineWrap" = "Yes" ]]; then
			availablespace=$(($(tput cols) - logowidth + 16)) #I dont know why 16 but it works
			new_out_array=("${out_array[0]}")
			for ((i=1; i<${#out_array[@]}; i++)); do
				lines=$(echo "${out_array[i]}" | fmt -w $availablespace)
				IFS=$'\n' read -rd '' -a splitlines <<<"$lines"
				new_out_array+=("${splitlines[0]}")
				for ((j=1; j<${#splitlines[*]}; j++)); do
					line=$(echo -e "$labelcolor $textcolor  ${splitlines[j]}")
					new_out_array=( "${new_out_array[@]}" "$line" );
				done
			done
			out_array=("${new_out_array[@]}")
		fi
		missinglines=$((${#out_array[*]} + startline - ${#fulloutput[*]}))
		for ((i=0; i<missinglines; i++)); do
			fulloutput+=("${c1}$(printf '%s' "$logowidth")")
		done
		#n=${#fulloutput[*]}
		for ((i=0; i<${#fulloutput[*]}; i++)); do
			# echo "${out_array[@]}"
			case $(awk 'BEGIN{srand();print int(rand()*(1000-1))+1 }') in
				411|188|15|166|609)
					f_size=${#fulloutput[*]}
					o_size=${#out_array[*]}
					f_max=$(( 32768 / f_size * f_size ))
					#o_max=$(( 32768 / o_size * o_size ))
					for ((a=f_size-1; a>0; a--)); do
						while (( (rand=RANDOM) >= f_max )); do :; done
						rand=$(( rand % (a+1) ))
						tmp=${fulloutput[a]} fulloutput[a]=${fulloutput[rand]} fulloutput[rand]=$tmp
					done
					for ((b=o_size-1; b>0; b--)); do
						rand=$(( rand % (b+1) ))
						tmp=${out_array[b]} out_array[b]=${out_array[rand]} out_array[rand]=$tmp
					done
				;;
			esac
			printf "${fulloutput[i]}$c0\n" "${out_array[0]}"
			if [[ "$i" -ge "$startline" ]]; then
				unset 'out_array[0]'
				out_array=( "${out_array[@]}" )
			fi
		done
	fi
	# Done with ASCII output
}

infoDisplay () {
	textcolor="\033[0m"
	[[ "$my_hcolor" ]] && textcolor="${my_hcolor}"
	#TODO: Centralize colors and use them across the board so we only change them one place.
	myascii="${distro}"
	[[ "${asc_distro}" ]] && myascii="${asc_distro}"
	case ${myascii} in
		"Alpine Linux"|"Arch Linux - Old"|"ArcoLinux"|"blackPanther OS"|"Fedora"|"Korora"|"Chapeau"|"Mandriva"|"Mandrake"| \
		"Chakra"|"ChromeOS"|"Sabayon"|"Slackware"|"Mac OS X"|"Trisquel"|"Kali Linux"|"Jiyuu Linux"|"Antergos"| \
		"KaOS"|"Logos"|"gNewSense"|"Netrunner"|"NixOS"|"SailfishOS"|"Qubes OS"|"Kogaion"|"PCLinuxOS"| \
		"Obarun"|"Siduction"|"BOB"|"SwagArch"|"Parrot Security"|"Zorin OS")
			labelcolor=$(getColor 'light blue')
		;;
		"Arch Linux"|"Artix Linux"|"Frugalware"|"Mageia"|"Deepin"|"CRUX"|"OS Elbrus"|"EndeavourOS")
			labelcolor=$(getColor 'light cyan')
		;;
		"Mint"|"LMDE"|"KDE neon"|"openSUSE"|"SUSE Linux Enterprise"|"LinuxDeepin"|"DragonflyBSD"|"Manjaro"| \
		"Manjaro-tree"|"Android"|"Void Linux"|"DesaOS")
			labelcolor=$(getColor 'light green')
		;;
		"Ubuntu"|"FreeBSD"|"FreeBSD - Old"|"Debian"|"Raspbian"|"BSD"|"Red Hat Enterprise Linux"|"Oracle Linux"| \
		"Peppermint"|"Cygwin"|"Msys"|"Fuduntu"|"Scientific Linux"|"DragonFlyBSD"|"BackTrack Linux"|"Red Star OS"| \
		"SparkyLinux"|"OBRevenge"|"Source Mage GNU/Linux")
			labelcolor=$(getColor 'light red')
		;;
		"ROSA"|"januslinux")
			labelcolor=$(getColor 'white')
		;;
		"CrunchBang"|"Viperr"|"elementary"*)
			labelcolor=$(getColor 'dark grey')
		;;
		"Gentoo"|"Parabola GNU/Linux-libre"|"Funtoo"|"Funtoo-text"|"BLAG"|"SteamOS"|"Devuan")
			labelcolor=$(getColor 'light purple')
		;;
		"Haiku")
			labelcolor=$(getColor 'green')
		;;
		"NetBSD"|"Amazon Linux"|"Proxmox VE")
			labelcolor=$(getColor 'orange')
		;;
		"CentOS")
			labelcolor=$(getColor 'yellow')
		;;
		"Hyperbola GNU/Linux-libre"|"PureOS"|*)
			labelcolor=$(getColor 'light grey')
		;;
	esac
	[[ "$my_lcolor" ]] && labelcolor="${my_lcolor}"
	if [[ "$art" ]]; then
		source "$art"
	fi
	if [[ "$no_color" == "1" ]]; then
		labelcolor=""
		bold=""
		c0=""
		textcolor=""
	fi
	# Some verbosity stuff
	[[ "$screenshot" == "1" ]] && verboseOut "Screenshot will be taken after info is displayed."
	[[ "$upload" == "1" ]] && verboseOut "Screenshot will be transferred/uploaded to specified location."
	#########################
	# Info Variable Setting #
	#########################
	if [[ "${distro}" == "Android" ]]; then
		myhostname=$(echo -e "${labelcolor} ${hostname}"); out_array=( "${out_array[@]}" "$myhostname" )
		mydistro=$(echo -e "$labelcolor OS:$textcolor $distro $distro_ver"); out_array=( "${out_array[@]}" "$mydistro" )
		mydevice=$(echo -e "$labelcolor Device:$textcolor $device"); out_array=( "${out_array[@]}" "$mydevice" )
		myrom=$(echo -e "$labelcolor ROM:$textcolor $rom"); out_array=( "${out_array[@]}" "$myrom" )
		mybaseband=$(echo -e "$labelcolor Baseband:$textcolor $baseband"); out_array=( "${out_array[@]}" "$mybaseband" )
		mykernel=$(echo -e "$labelcolor Kernel:$textcolor $kernel"); out_array=( "${out_array[@]}" "$mykernel" )
		myuptime=$(echo -e "$labelcolor Uptime:$textcolor $uptime"); out_array=( "${out_array[@]}" "$myuptime" )
		mycpu=$(echo -e "$labelcolor CPU:$textcolor $cpu"); out_array=( "${out_array[@]}" "$mycpu" )
		mygpu=$(echo -e "$labelcolor GPU:$textcolor $cpu"); out_array=( "${out_array[@]}" "$mygpu" )
		mymem=$(echo -e "$labelcolor RAM:$textcolor $mem"); out_array=( "${out_array[@]}" "$mymem" )
	else
	    display_list=""
		for (( i = 0; i < ${#display[@]}; i++ ))
        do
          display_list="$display_list ${display[$i]}"
        done
		if [[ "${display_list}" =~ "host" ]]; then
			myinfo=$(echo -e "${labelcolor} ${myUser}$textcolor${bold}@${c0}${labelcolor}${myHost}")
			out_array=( "${out_array[@]}" "$myinfo" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "distro" ]]; then
			if [ "$distro" == "Mac OS X" ]; then
				sysArch="$(getconf LONG_BIT)bit"
				prodVers=$(sw_vers | grep 'ProductVersion')
				prodVers=${prodVers:16}
				buildVers=$(sw_vers |grep 'BuildVersion')
				buildVers=${buildVers:14}
				#if [ -n "$distro_more" ]; then
				#	mydistro=$(echo -e "$labelcolor OS:$textcolor $distro_more $sysArch")
				#else
					mydistro=$(echo -e "$labelcolor OS:$textcolor $sysArch $distro $prodVers $buildVers")
				#fi
			elif [[ "$distro" == "Cygwin" || "$distro" == "Msys" ]]; then
				distro="$(wmic os get caption | sed 's/\r//g; s/[ \t]*$//g; 2!d')"
				if [[ "$(wmic os get version | grep -o '^10\.')" == "10." ]]; then
					distro="$distro (v$(wmic os get version | grep '^10\.' | tr -d ' '))"
				fi
				sysArch=$(wmic os get OSArchitecture | sed 's/\r//g; s/[ \t]*$//g; 2!d')
				mydistro=$(echo -e "$labelcolor OS:$textcolor $distro $sysArch")
			else
				#if [ -n "$distro_more" ]; then
				#	mydistro=$(echo -e "$labelcolor OS:$textcolor $distro_more")
				#else
					mydistro=$(echo -e "$labelcolor OS:$textcolor $distro $sysArch")
				#fi
			fi
			out_array=( "${out_array[@]}" "$mydistro$wsl" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "kernel" ]]; then
			mykernel=$(echo -e "$labelcolor Kernel:$textcolor $kernel")
			out_array=( "${out_array[@]}" "$mykernel" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "uptime" ]]; then
			myuptime=$(echo -e "$labelcolor Uptime:$textcolor $uptime")
			out_array=( "${out_array[@]}" "$myuptime" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "shell" ]]; then
			myshell=$(echo -e "$labelcolor Shell:$textcolor $myShell")
			out_array=( "${out_array[@]}" "$myshell" )
			((display_index++))
		fi
		if [[ -n "$DISPLAY" || "$distro" == "Mac OS X" ]]; then
			if [ -n "${xResolution}" ]; then
				if [[ "${display_list}" =~ "res" ]]; then
					myres=$(echo -e "$labelcolor Resolution:${textcolor} $xResolution")
					out_array=( "${out_array[@]}" "$myres" )
					((display_index++))
				fi
			fi
			if [[ "${display_list}" =~ "de" ]]; then
				if [[ "${DE}" != "Not Present" ]]; then
					myde=$(echo -e "$labelcolor DE:$textcolor $DE")
					out_array=( "${out_array[@]}" "$myde" )
					((display_index++))
				fi
			fi
			if [[ "${display_list}" =~ "wm" ]]; then
				mywm=$(echo -e "$labelcolor WM:$textcolor $WM")
				out_array=( "${out_array[@]}" "$mywm" )
				((display_index++))
			fi
			if [[ "${display_list}" =~ "wmtheme" ]]; then
				if [[ "${Win_theme}" != "Not Applicable" && "${Win_theme}" != "Not Found" ]]; then
					mywmtheme=$(echo -e "$labelcolor WM Theme:$textcolor $Win_theme")
					out_array=( "${out_array[@]}" "$mywmtheme" )
					((display_index++))
				fi
			fi
			if [[ "${display_list}" =~ "gtk" ]]; then
				if [ "$distro" == "Mac OS X" ]; then
					if [[ "$gtkFont" != "Not Applicable" && "$gtkFont" != "Not Found" ]]; then
						if [ -n "$gtkFont" ]; then
							myfont=$(echo -e "$labelcolor Font:$textcolor $gtkFont")
							out_array=( "${out_array[@]}" "$myfont" )
							((display_index++))
						fi
					fi
				else
					if [[ "$gtk2Theme" != "Not Applicable" && "$gtk2Theme" != "Not Found" ]]; then
						if [ -n "$gtk2Theme" ]; then
							mygtk2="${gtk2Theme} [GTK2]"
						fi
					fi
					if [[ "$gtk3Theme" != "Not Applicable" && "$gtk3Theme" != "Not Found" ]]; then
						if [ -n "$mygtk2" ]; then
							mygtk3=", ${gtk3Theme} [GTK3]"
						else
							mygtk3="${gtk3Theme} [GTK3]"
						fi
					fi
					if [[ "$gtk_2line" == "yes" ]]; then
						mygtk2=$(echo -e "$labelcolor GTK2 Theme:$textcolor $gtk2Theme")
						out_array=( "${out_array[@]}" "$mygtk2" )
						((display_index++))
						mygtk3=$(echo -e "$labelcolor GTK3 Theme:$textcolor $gtk3Theme")
						out_array=( "${out_array[@]}" "$mygtk3" )
						((display_index++))
					else
						if [[ "$gtk2Theme" == "$gtk3Theme" ]]; then
							if [[ "$gtk2Theme" != "Not Applicable" && "$gtk2Theme" != "Not Found" ]]; then
								mygtk=$(echo -e "$labelcolor GTK Theme:$textcolor ${gtk2Theme} [GTK2/3]")
								out_array=( "${out_array[@]}" "$mygtk" )
								((display_index++))
							fi
						else
							mygtk=$(echo -e "$labelcolor GTK Theme:$textcolor ${mygtk2}${mygtk3}")
							out_array=( "${out_array[@]}" "$mygtk" )
							((display_index++))
						fi
					fi
					if [[ "$gtkIcons" != "Not Applicable" && "$gtkIcons" != "Not Found" ]]; then
						if [ -n "$gtkIcons" ]; then
							myicons=$(echo -e "$labelcolor Icon Theme:$textcolor $gtkIcons")
							out_array=( "${out_array[@]}" "$myicons" )
							((display_index++))
						fi
					fi
					if [[ "$gtkFont" != "Not Applicable" && "$gtkFont" != "Not Found" ]]; then
						if [ -n "$gtkFont" ]; then
							myfont=$(echo -e "$labelcolor Font:$textcolor $gtkFont")
							out_array=( "${out_array[@]}" "$myfont" )
							((display_index++))
						fi
					fi
				fi
			fi
		elif [[ "$distro" == "Haiku" && -n "${xResolution}" && "${display_list}" =~ "res" ]]; then
			myres=$(echo -e "$labelcolor Resolution:${textcolor} $xResolution")
			out_array=( "${out_array[@]}" "$myres" )
			((display_index++))
		fi
		if [[ "${fake_distro}" != "Cygwin" && "${fake_distro}" != "Msys" && "${fake_distro}" != "Windows - Modern" && "${display_list}" =~ "disk" ]]; then
			mydisk=$(echo -e "$labelcolor Disk:$textcolor $diskusage")
		 	out_array=( "${out_array[@]}" "$mydisk" )
		 	((display_index++))
		fi
		if [[ "${display_list}" =~ "cpu" ]]; then
			mycpu=$(echo -e "$labelcolor CPU:$textcolor $cpu")
			out_array=( "${out_array[@]}" "$mycpu" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "gpu" ]] && [[ "$gpu" != "Not Found" ]]; then
			mygpu=$(echo -e "$labelcolor GPU:$textcolor $gpu")
			out_array=( "${out_array[@]}" "$mygpu" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "mem" ]]; then
			mymem=$(echo -e "$labelcolor RAM:$textcolor $mem")
			out_array=( "${out_array[@]}" "$mymem" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "node" ]]; then
			mynode=$(echo -e "$labelcolor K8s NODE:$textcolor $node")
			out_array=( "${out_array[@]}" "$mynode" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "ip" ]]; then
			myip=$(echo -e "$labelcolor K8s IP:$textcolor $ip")
			out_array=( "${out_array[@]}" "$myip" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "pod" ]]; then
			mypod=$(echo -e "$labelcolor K8s POD:$textcolor $pod")
			out_array=( "${out_array[@]}" "$mypod" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "namespace" ]]; then
			mynamespace=$(echo -e "$labelcolor K8s NAMESPACE:$textcolor $namespace")
			out_array=( "${out_array[@]}" "$mynamespace" )
			((display_index++))
		fi
		if [[ "${display_list}" =~ "sa" ]]; then
			mysa=$(echo -e "$labelcolor K8s SERVICE ACCOUNT:$textcolor $sa")
			out_array=( "${out_array[@]}" "$mysa" )
			((display_index++))
		fi
		if [[ "$use_customlines" = 1 ]]; then
			customlines
		fi
	fi
	if [[ "$display_type" == "ASCII" ]]; then
		asciiText
	else
		if [[ "${display_list}" =~ "host" ]]; then echo -e "$myinfo"; fi
		if [[ "${display_list}" =~ "distro" ]]; then echo -e "$mydistro"; fi
		if [[ "${display_list}" =~ "kernel" ]]; then echo -e "$mykernel"; fi
		if [[ "${distro}" == "Android" ]]; then
			echo -e "$mydevice"
			echo -e "$myrom"
			echo -e "$mybaseband"
			echo -e "$mykernel"
			echo -e "$myuptime"
			echo -e "$mycpu"
			echo -e "$mymem"
		else
			if [[ "${display_list}" =~ "uptime" ]]; then echo -e "$myuptime"; fi
			if [[ "${display_list}" =~ "pkgs" && "$mypkgs" != "Unknown" ]]; then echo -e "$mypkgs"; fi
			if [[ "${display_list}" =~ "shell" ]]; then echo -e "$myshell"; fi
			if [[ "${display_list}" =~ "res" ]]; then
				test -z "$myres" || echo -e "$myres"
			fi
			if [[ "${display_list}" =~ "de" ]]; then
				if [[ "${DE}" != "Not Present" ]]; then echo -e "$myde"; fi
			fi
			if [[ "${display_list}" =~ "wm" ]]; then
				test -z "$mywm" || echo -e "$mywm"
				if [[ "${Win_theme}" != "Not Applicable" && "${Win_theme}" != "Not Found" ]]; then
					test -z "$mywmtheme" || echo -e "$mywmtheme"
				fi
			fi
			if [[ "${display_list}" =~ "gtk" ]]; then
				if [[ "$gtk_2line" == "yes" ]]; then
					test -z "$mygtk2" || echo -e "$mygtk2"
					test -z "$mygtk3" || echo -e "$mygtk3"
				else
					test -z "$mygtk" || echo -e "$mygtk"
				fi
				test -z "$myicons" || echo -e "$myicons"
				test -z "$myfont" || echo -e "$myfont"
			fi
			if [[ "${display_list}" =~ "disk" ]]; then echo -e "$mydisk"; fi
			if [[ "${display_list}" =~ "cpu" ]]; then echo -e "$mycpu"; fi
			if [[ "${display_list}" =~ "gpu" ]]; then echo -e "$mygpu"; fi
			if [[ "${display_list}" =~ "mem" ]]; then echo -e "$mymem"; fi
		fi
	fi
}

##################
# Let's Do This!
##################

#if [[ -f "$HOME/.infoOR" ]]; then
#	source "$HOME/.infoOR"
#fi

if [[ "$overrideDisplay" ]]; then
	verboseOut "Found 'd' flag in syntax. Overriding display..."
	OLDIFS=$IFS
	IFS=';'
	for i in ${overrideDisplay}; do
		modchar="${i:0:1}"
		if [[ "${modchar}" == "-" ]]; then
			i=${i/${modchar}}
			_OLDIFS=IFS
			IFS=,
			for n in $i; do
				if [[ ! "${display_list}" =~ "$n" ]]; then
					echo "The var $n is not currently being displayed."
				else
					for e in "${!display[@]}"; do
						if [[ ${display[e]} = "$n" ]]; then
							unset 'display[e]'
						fi
					done
				fi
			done
			IFS=$_OLDIFS
		elif [[ "${modchar}" == "+" ]]; then
			i=${i/${modchar}}
			_OLDIFS=IFS
			IFS=,
			for n in $i; do
				if [[ "${display_list}" =~ "$n" ]]; then
					if [[ "${display_list}" =~ "$n" ]]; then
						echo "The $n var is already being displayed."
					else
						display+=("$n")
					fi
				else
					echo "The var $n is not a valid display var."
				fi
			done
			IFS=$_OLDIFS
		else
			IFS=$OLDIFS
			i="${i//,/ }"
			display=( "$i" )
		fi
	done
	IFS=$OLDIFS
fi

for i in "${display[@]}"; do
	if [[ -n "$i" ]]; then
		if [[ $i =~ wm ]]; then
			test -z "$WM" && detectwm
			test -z "$Win_theme" && detectwmtheme
		else
			if [[ "${display[*]}" =~ "$i" ]]; then
				if [[ "$errorSuppress" == "1" ]]; then
					detect"${i}" 2>/dev/null
				else
					detect"${i}"
				fi
			fi
		fi
	fi
done

# Check for android
if [[ -f /system/build.prop  && "${distro}" != "SailfishOS" ]]; then
    distro="Android"
    detectmem
    detectuptime
    detectkernel
    detectdroid
    infoDisplay
    exit 0
fi

if [ "$gpu" = 'Not Found' ] ; then
	DetectIntelGPU
fi


infoDisplay

exit 0

